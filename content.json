{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://juzzing2.github.io.com"},"pages":[],"posts":[{"title":"react-router v4","slug":"v4","date":"2019-01-22T07:49:59.000Z","updated":"2019-02-07T04:25:24.000Z","comments":true,"path":"2019/01/22/v4/","link":"","permalink":"http://juzzing2.github.io.com/2019/01/22/v4/","excerpt":"","text":"기존 프로젝트 버전 업하는 작업을 하기전 테스트를 해보았다.react 15.3.2 –&gt; 16.7.0webpack 1.13.2 –&gt; 4.19.0babel 6.2.5 –&gt; 7.0.0 babel7+ 버전부터는 babel-plugin-syntax-trailing-function-commas 를 사용하여 파라미터들을 나열할 때 마지막 파라미터에 콤마(,)를 허용한다.그러나 마지막 파라미터에 object spread 연산자가 있는 경우 콤마 (,) 를 허용하지 않는다. 123456789101112const &#123; style, color, width, // 가능&#125; = this.props; const &#123; style, color, ...other, ---&gt; 이 부분을 ...other로 수정&#125; = this.props; Router v4 - browserRouter (webpack 설정) react-router v4부터는 라우터가 컴포넌트 개념이라고 생각하면 된다. hashRouter를 사용하는 경우 현재 프로젝트와 동일하게 작업을 하면 된다. 그러나 browserRouter를 사용하는 경우에는 아래와 같이 webpack.config 파일 설정이 필요하다. 12345678module.exports = &#123; ... devServer: &#123; contentBase: path.join(__dirname,'src'), disableHostCheck: true, // realgrid때문에 host파일 설정을 하는데 설정을 해줘야 lululala.co.kr이런식으로 접근할 수 있다. historyApiFallback: true // browserRouter사용하는 경우 /밑에 app안에 정의된 router 로 이동할 수 있다. &#125;,&#125; browserRouter를 사용하는 경우에 www.lululala.co.kr/rocket/LUXButton –&gt; 이 경우 build된 파일의 경로를 바로 잡지 못해 아래와 같은 에러가 발생한다.이는 해당 주소를 서버에 요청하면 서버 쪽 라우터에서 먼저 연결할 곳이 있는지 확인해보고 없으면 오류가 발생한다.이를 해결하기 위해서는 webpack에서 publicPath 설정을 해야한다.publicPath란 서비스가 시작되는 루트경로를 제외한 상대경로를 설정하는 것이다. 즉, 웹팩에 의해 빌드될 때 사용되는 경로이다. 기존 publicPath 적용 후 Router Splitting기존에는 react-loadable 라이브러리를 사용하여 페이지가 로더될 때와 로딩될 때를 구분하여 사용할 수 있었다.1234567891011import loadable from 'react-loadable'; const AboutComponentPage = () =&gt; &#123; return import('./about');&#125; const AsynAboutComponent = loadable( &#123; loader: AboutComponentPage, // 로드될 페이지 loading: Loading //로딩 될때&#125;); react 16.6 부터 react에서 지원하는 Lazy, Suspense를 사용하면 된다.dynamic import 를 통해서 사용한다. 아직 로딩이 되지 않은 lazy컴포넌트의 fallback을 suspense 를 통해 표시할 수 있다. 123456789101112import React, &#123; Suspense, lazy &#125; from 'react'const ErrorDialogComponent = lazy(() =&gt; import('./Documents/LUXErrorDialog/ErrorDialogDocument'));const Loading = () =&gt; &lt;div&gt;loading...&lt;/div&gt; render&#123; return ( &lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt; &lt;Route path=&#123;`$&#123;this.props.match.path&#125;/LUXButton`&#125; render=&#123;(props) =&gt; &lt;ErrorDialogComponent &#123;...props&#125; /&gt;&#125; onEnter=&#123;scrollToTop&#125;/&gt; &lt;/Suspense&gt; )&#125;","categories":[],"tags":[{"name":"react-router v4","slug":"react-router-v4","permalink":"http://juzzing2.github.io.com/tags/react-router-v4/"}]},{"title":"this란","slug":"this","date":"2019-01-17T02:39:09.000Z","updated":"2019-01-17T04:04:54.000Z","comments":true,"path":"2019/01/17/this/","link":"","permalink":"http://juzzing2.github.io.com/2019/01/17/this/","excerpt":"","text":"this란 무엇인가?자바스크립트 개발자로 어느덧 2년차가 되어가지만 this가 뭐냐고 물으면 답을 못할 것 같다.그러므로 this에 대해 정리해보자. ###1. 실행문맥this란 실행문맥 즉, 호출자가 누구인지를 의미한다. 123456const caller = &#123; f: function() &#123; alert(this === window) &#125;,&#125;caller.f() // false, 호출자는 caller 객체 ###2. 생성자 함수내의 this는 new를 통해 만들어진 새로운 변수1234567891011function NewObject(name, color) &#123; this.name = name this.color = color this.isWindow = function() &#123; return this === window &#125;&#125;const newObj = new NewObject('nana', 'yellow')console.log(newObj.name) // nanaconsole.log(newObj.color) // yellow ###3. bind, arrow function123456789function Family(firstName) &#123; this.firstName = firstName const names = ['bill', 'mark', 'steve'] names.map((value, index) =&gt; &#123; console.log(value + ' ' + this.firstName) &#125;)&#125;const kims = new Family('kim') 실행하면 콘솔에 this.firstName값이 undefined로 찍히게 된다.이는 map의 context(this)로 바인딩 되지 않기 때문이다. 그래서 bind.this(this)를 붙이거나ES6부터는 arrow function(=&gt;)을 사용하면 된다. 123456789function Family(firstName) &#123; this.firstName = firstName const names = ['bill', 'mark', 'steve'] names.map((value, index) =&gt; &#123; console.log(value + ' ' + this.firstName) &#125;)&#125;const kims = new Family('kim')","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://juzzing2.github.io.com/tags/javascript/"}]},{"title":"process_env","slug":"process-env","date":"2019-01-15T06:31:37.000Z","updated":"2019-01-15T07:21:59.000Z","comments":true,"path":"2019/01/15/process-env/","link":"","permalink":"http://juzzing2.github.io.com/2019/01/15/process-env/","excerpt":"","text":"a라는 프로젝트에서 b,c의 라이브러리를 땡기고 있는 상황에서 에러가 발생하였다.b라이브러리가 참조하고 있는 d 프로젝트에서 전역상수인 process.env.NODE_ENV 값을 찾지 못해 발생한 에러였다.a프로젝트는 process.env.NODE_ENV값이 없기 때문이었다.이전에 대충 알기는 했는데 막상 에러가 나니까 어디서 발생한지 몰랐다.이번 기회에 알아보자… 먼저 webpack.config.js이 파일에 DefinePlugin이라는 로더를 사용해서 정의한다.DefinePlugin은 컴파일 타임에 구성할 수 있는 전역상수를 만든다.12345678plugins: [ new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: JSON.stringify(process.env.NODE_ENV), BUILD_ENV: JSON.stringify(process.env.NODE_ENV) &#125; &#125;),], 이렇게 process.env 값을 전역 상수로 설정하고 필요한 곳에서 마음대로 꺼내 쓸 수있다.보통 빌드 상태가 dev인지 production인지 분기처리할 때 사용한다.package.json 파일을 보면 아래와 같다. 1234567891011121314151617181920&#123;\"start\": \"npm run play &amp;&amp; NODE_ENV=dev\",\"play\": \"NODE_ENV=dev webpack-dev-server --config webpack-dev-server.config.js --progress --inline --colors\"&#125;``` npm start 명령어를 실행하면 `NODE_ENV` 의 값은 dev가 된다.만약 명령어부분에 따로 설정을하지 않은 경우 로더 설정하는 부분에 아래와 같이 값을 고정시켜놓으면 된다. ``` javascriptplugins: [ new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: JSON.stringify('production'), BUILD_ENV: JSON.stringify('production') &#125; &#125;),], 한가지 더 종종 큰 프로젝트를 실행하다보면 아래와 같은 문구를 볼 수 있다.1\"FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory\" 메모리 문제이다. 그럴때는 해결책으로 install을 하면 된다.12npm install -g increase-memory-limitincrease-memory-limit 또는 아예 스크립트 start 명령어에 NODE_OPTIONS=--max_old_space_size= 설정을 해주면 된다. 오늘도 또한 느낀점은 내가 약 2년정도 동안 참 한게 많이 없고 많이 많이 부족한것을 느끼게 되었다… 후.. 열심히 공부하자.","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://juzzing2.github.io.com/tags/webpack/"}]},{"title":"몰랐던 사실 (컴포넌트 생성)","slug":"surprise1","date":"2019-01-14T06:00:49.000Z","updated":"2019-01-14T06:04:33.000Z","comments":true,"path":"2019/01/14/surprise1/","link":"","permalink":"http://juzzing2.github.io.com/2019/01/14/surprise1/","excerpt":"","text":"얼마전에 엄청 놀라운 것을 발견했다.react 16.4버전 이상 미지원 react-tap-event-plugin 를 지원하지 않아 onTouchTap이 작동하지 않게 되어 찾아보던 중material-ui 신규 라이브러리에서 알게된 사실이다.123456const btn = 'button';render() &#123; return( &lt;btn/&gt; )&#125; 이렇게하면 버튼 태그가 생성된다. 마찬가지로 span, input 다 만들어진다.새롭게 하나 배웠다.","categories":[],"tags":[]},{"title":"forLoop","slug":"forloop","date":"2019-01-14T05:21:37.000Z","updated":"2019-01-14T06:06:37.000Z","comments":true,"path":"2019/01/14/forloop/","link":"","permalink":"http://juzzing2.github.io.com/2019/01/14/forloop/","excerpt":"","text":"기존에 배열같은 경우는 반복문을 사용할 때 용도에 따라서 forEach 와 map을 사용했었다.그런데 Object같은 경우는 반복문을 어떻게 사용해야하는지 순간 까먹었었다.그래서 반복문에 대해서 정리가 필요했다. forEachforEach문 밖으로 리턴값을 받지 못한다. 사용할때는 for문안에서 어떤한 작업을 하고 싶을 때 사용한다. 123let arr = [1,2,3];let b = arr.forEach((v) =&gt; &#123; return v;&#125;)console.log(\"b\", b); //undefiend map새로운 배열을 리턴한다.성능면에서도 map이 더 우수하다. map사용을 권장하는 분위기이다. 123let arr = [1,2,3];let b = arr.forEach((v) =&gt; &#123; return v + 1;&#125;)console.log(\"b\", b); //[2,3,4] for in객체의 속성들을 반복하여 작업수행 가능하다. key값에 접근할 수만있다.여기서 hasOwnProperty로 각각의 object값들을 빼도 된다.hasOwnProperty는 자신의 고유 속성, 즉 상속받은 프로퍼티가 아닌 순수 자신의 속성인 경우에만 값을 true로 반환한다. 12345678910111213var obj = &#123; a: 1, b: 2, c: 3&#125;;for (let i in obj) &#123; console.log(i); // a, b, c console.log(obj[i]); //1,2,3 if (obj.hasOwnProperty(i)) &#123; console.log(obj[i]) &#125;&#125; for ofES6에 추가된 반복구문이다. 컬렉션 객체가 [Symbol.iterator]속성을 가지고 있어야만한다. 12345let iterable = [10, 20, 30];for (let value of iterable) &#123; console.log(value); // 10, 20, 30&#125; 객체를 반복문 돌리는 방법 12345var obj = &#123; first: \"John\", last: \"Doe\" &#125;;Object.keys(obj).forEach(function(key) &#123; console.log(key, obj[key]);&#125;); 123for (const key of Object.keys(obj)) &#123; console.log(key, obj[key]);&#125; 123Object.entries(obj).forEach( ([key, value]) =&gt; console.log(key, value));","categories":[],"tags":[{"name":"for in/ for of문","slug":"for-in-for-of문","permalink":"http://juzzing2.github.io.com/tags/for-in-for-of문/"}]},{"title":"timelinejs","slug":"timelinejs","date":"2019-01-10T02:44:51.000Z","updated":"2019-01-10T04:47:53.000Z","comments":true,"path":"2019/01/10/timelinejs/","link":"","permalink":"http://juzzing2.github.io.com/2019/01/10/timelinejs/","excerpt":"","text":"TimeLineJS라이브러리를 사용하여 차트 컴포넌트를 만들게 되었다.https://timeline.knightlab.com/ 참고 외부 라이브러리를 커스텀하면서 가장 힘들었던 점은 컴포넌트화 작업을 하는 부분이었다.나만 쓰는게 아니라 다른 개발자들이 사용할 수 있게 표준화된 컴포넌트를 만드는 일은 참 힘들었다.아래는 개발하면서 힘들었던 점들에 대해 짚어볼 것이다. 해당 라이브러리는 javascript파일로 되었있지만 모든 기능들을 한 파일에 다 모아놓았다.일일히 다 수정하기에는 너무 일이 커질 거 같아서 필요한 속성들만 받을 수 있게 수정해놓았다.그런데 문제는 babel7.x.x 버전은 ES5 변환 불가능한 것들은 그냥 그대로 읽는거 같다. 하지만 우리 회사 전체 프로젝트는babel 6.x.x 버전은 모든 파일을 ES5로 변환하는 것 같다.(babel: browser가 인식할 수 있는 ES5 문법으로 변환시켜주는 transpiler이다.)해결책으로는 jsx파일로 만들었다. 왜냐하면 공통으로 webpack-dev-server.config.js 파일에 js파일만 babel로 컴파일하기로되어있기 때문이다.그러나 큰 문제가 또 발생했다. 개발된 프로젝트를 build돌리면 jsx파일도 컴파일을 시키는 것이다.일일히 수동으로 빌드 돌릴 때마다 jsx파일을 바꿔치기 할 수 도 없다.해결책으로는 package.json에 빌드명령에 npm run build:babel &amp;&amp; npm run build:copy-files 이렇게 되어 있다.src하위 폴더를 다 빌드시키고 copy-files라는 파일에 있는 것들도 함께 빌드를 시키라는 명령어이다.그래서 copy-files.js 파일에 가서 복사할 파일의 경로를 추가하였다. 123456789101112131415161718192021222324252627/* eslint-disable no-console */const files = [ 'README.md', 'CHANGELOG.md', 'LICENSE', './src/ARITimeLine/ARITimeLineLib.jsx' // 이 부분!!! ];Promise.all( files.map((file) =&gt; copyFile(file))) .then(() =&gt; createPackageFile());function copyFile(file) &#123; const buildPath = resolveBuildPath(file); return new Promise((resolve) =&gt; &#123; fse.copy( file, buildPath, (err) =&gt; &#123; if (err) throw err; resolve(); &#125; ); &#125;) .then(() =&gt; console.log(`Copied $&#123;file&#125; to $&#123;buildPath&#125;`));&#125; 이 방법이 맞나 싶기는 한데 timelinejs라이브러리를 일일히 다 커스텀하기에는 아무래도 일 이 커질 것 같다. 컴포넌트화 시키고 다른 프로젝트에서 import해서 쓰는데 문제가 발생했다.Minified React error 에러였다. 찾아보니 react 에서 와이어를 통해 보내는 바이트 수를 줄이기 위해 전체 에러를 보내는 것을피한다고 한다. 결국 타임라인을 개발한 프로젝트로 가서 오류를 보니 render에서 return할 때 timeline라이브러리를 리턴하는데이게 object 형태로 되어 있어 발생한 에러였다. 항상 return할때는 배열이나 Fragments를 사용하여 자식목록을 그룹화한다.내가 사용한 방법은 react-addons-create-fragment를 사용했는데 더이상 안쓰인다. react 16버전부터는 Fragment를 지원한다.그러나 우리회사는 react 15버전이므로 사용했다. 12345678910111213141516171819202122232425import createFragment from 'react-addons-create-fragment';export function createChildFragment(fragments) &#123; const newFragments = &#123;&#125;; let validChildrenCount = 0; let firstKey; // Only create non-empty key fragments for (const key in fragments) &#123; //object의 key값만을 뽑아서 반복문 돌릴 때는 'for in'사용 let currentChild = fragments[key]; if (typeof currentChild === 'object') &#123; createChildFragment(currentChild) &#125; if (typeof currentChild === 'object') return; if (currentChild) &#123; if (validChildrenCount === 0) firstKey = key; newFragments[key] = currentChild; validChildrenCount++; &#125; &#125; if (validChildrenCount === 0) return undefined; if (validChildrenCount === 1) return newFragments[firstKey]; return createFragment(newFragments);&#125; 이렇게 해결을 하였다!!! 사실 내가 한 방법이 맞는지 모르겠지만 잘 돌아가니 우선 덮어두기로…","categories":[],"tags":[{"name":"TimeLineJS","slug":"timelinejs","permalink":"http://juzzing2.github.io.com/tags/timelinejs/"}]},{"title":"Next.js","slug":"next-js","date":"2018-12-19T00:05:43.000Z","updated":"2018-12-20T08:50:42.000Z","comments":true,"path":"2018/12/19/next-js/","link":"","permalink":"http://juzzing2.github.io.com/2018/12/19/next-js/","excerpt":"","text":"Next.js란 리액트 프레임워크이다.서버사이드 랜더링(SSR)을 지원하며 프론트 엔드를 위한 서버이다. 실제로 서버에서 사용할 코드를 주며 빌드되지 않고서버위에서 동작한다.CRA는 빌드된 파일이 소스로 올라가며 클라언트 랜더링이다. 서버사이드 렌더링(SSR)과 클라이언트 렌더링의 차이점?서버사이드 렌더링(SSR)은 웹사이트 접속해서 나에게 보여기지 전에 서버가 모든 데이터(모든 html)를 가져와서 보인다.그래서 페이지 이동을 할 때 불필요하게 로딩 페이지가 있을 필요가 없다.즉, 백엔드에 변환된 html이 복사되어 클라이언트에게 전달한다. next.js위에 백엔드 노드 서버가 있고 웹사이트를 갈 때마다react.js를 가져온다(익스프레스 서버)아래 그림은 next.js프로젝트의 index.html파일이다. 클라이언트 렌더링은 서버는 작은 html과 js파일을 주고 클라이언트에서 js파일을 읽어서 로딩을 한다. js파일을 받는데렌더링 되는동안에는 클라이언트에서는 화면을 볼 수 없다. 실제로 확인해보면 해당 페이지를 누를 때마다 해당 js파일을 불러오고 있다.최초에는 index.js파일만 불러온다. about을 누르면 해당 about.js파일을 불러오는 것을 볼 수 있다.이게 바로 서버사이드랜더링이다. 페이지를 동적으로 생성한다.서버가 실제로 props로 각 데이터들을 가지고 script태그에 넣는 것이다.react앱은 NEXT_DATA script를 hydrate하게 프로그래밍하게 되어있다..? 서버를 기반으로 돌아가게 하려면 server.js에 서버를 세팅한다. app.js =&gt; app컴포넌트는 일반 컴포넌트들 보다 최상위에 존재한다. 기존에 HoC랑 같다. 그래서 헤더영역이나 공통으로모든 페이지마다 들어가야할 요소를 app.js에 세팅한다. document.js =&gt; document를 통째로 서버쪽에서 렌더링 되는걸 바꾸고 싶을 때 사용한다.","categories":[],"tags":[]},{"title":"setState","slug":"setstate","date":"2018-12-17T05:27:37.000Z","updated":"2018-12-17T05:38:45.000Z","comments":true,"path":"2018/12/17/setstate/","link":"","permalink":"http://juzzing2.github.io.com/2018/12/17/setstate/","excerpt":"","text":"react에서 setState는 상태값 변화를 위해 사용한다.그러나 setState가 비동기적으로 일어나기 때문에 아래와 같이 코드를 작성하면 this.state.count의 값이 +1을 하기 전의 값이 나올 수도 있다.123this.setState(&#123; count: this.state.count + 1,&#125;); 그래서 함수형 setState를 사용한다. 12345this.setState(prevState =&gt; &#123; return &#123; count: prevState.count + 1, &#125; &#125;) 기존에 객체를 복사한 다음에 업데이트한 값을 setState하는 방식이다. 123let all = Object.assign(&#123;&#125;, this.state.all);all.name = 'hi';this.setState(&#123;all&#125;); 기존의 Object.assign을 대신해서 아래와 값이 사용하면 된다.123456this.setState(prevState =&gt; (&#123; all: &#123; ...prevState.all, name: 'hi', &#125;&#125;))","categories":[],"tags":[]},{"title":"context-api","slug":"context-api","date":"2018-12-17T04:49:59.000Z","updated":"2018-12-18T00:16:27.000Z","comments":true,"path":"2018/12/17/context-api/","link":"","permalink":"http://juzzing2.github.io.com/2018/12/17/context-api/","excerpt":"","text":"Context API는 props를 직접 전달하는 것과 바로 상태 전달이 가능하다.store를 두고서 상태값들을 서로 공유할 수 있다.기존의 redux 보다는 사용방법이 훨씬 간단하다. 우선 store공간을 만든다.(store.js)context는 createContext라는 함수를 통해 만든다.이 함수를 호출하면 Provider와 Consumer라는 컴포넌트들이 반환된다.1234import React from \"react\";const Store = React.createContext(null);export default Store; Context를 프로젝트에 적용하려면 최상단을 Provider로 감싸야한다.Provider 내에서 사용할 값은 “value”라고 부른다.클래스가 생성되었을 때 store가 value를 얻게 된다.그래서 Provider에 사용할 함수는 반드시 생성자에 명시해야한다.생성자에서 state 값 뿐만 아니라 함수도 선언해줘야한다.12345678910111213141516171819202122232425262728293031323334import React, &#123; Component &#125; from \"react\";import AppPresenter from \"./AppPresenter\";import Store from \"store\";class AppContainer extends Component &#123; constructor() &#123; super(); this._changeMessage = () =&gt; &#123; if (this.state.message === 'hello') &#123; this.setState(&#123; message: 'bye bye', &#125;) &#125; else &#123; this.setState(&#123; message: 'hello', &#125;) &#125; &#125; this.state = &#123; message: 'hi', changeMessage: this.__changeMessage, &#125; &#125; render()&#123; return( &lt;Store.Provider value=&#123;this.state&#125;&gt; &lt;AppPresenter/&gt; &lt;/Store.Provider&gt; ) &#125;&#125;export default AppContainer; Consumer는 Context를 사용해야할 때 사용한다.Consumer는 함수가 아닌 다른 child를 사용하면 안된다. 123456789101112131415161718192021import React, &#123; Fragment &#125; from \"react\";import Notification from \"Components/Notification\";import Store from 'store';const AppPresenter = () =&gt; ( &lt;Fragment&gt; &lt;Store.Consumer&gt; &#123;store =&gt; (&lt;Notification key=&#123;store.notification[key].id&#125; id=&#123;store.notification[key].id&#125; text=&#123;store.notification[key].text&#125; seen=&#123;store.notification[key].seen&#125; onClick=&#123;store.changeMessage&#125; /&gt; ) &#125; &#125; &lt;/Store.Consumer&gt; &lt;/Fragment&gt;);export default AppPresenter; context가 여러개 있을 때 Provider를 각각 생성해서 최상위에 여러겹 쌓는게 마음에 걸린다.자바스크립트 내장함수인 reduce를 사용하여 깔끔하게 정리할 수 있다.123456789101112131415161718192021import React from 'react';import &#123; SampleProvider &#125; from './contexts/sample';import &#123; AnotherProvider &#125; from \"./contexts/another\";const AppProvider = (&#123;contexts, children&#125;) =&gt; contexts.reduce( (prev, context) =&gt; React.createElement(context, &#123; children: prev &#125;), children);const App = () =&gt; &#123; return ( &lt;AppProvider contexts=&#123;[SampleProvider, AnotherProvider]&#125; &gt; &lt;/AppProvider&gt; );&#125;;export default App; 또한 Consumer에 사용되는 로직을 쉽게 재사용할 수 있도록 HoC를 사용한다면 매우 편리해진다. 1234567891011121314151617181920212223import React, &#123; Component, createContext &#125; from 'react';const Context = createContext();const&#123; Provider, Consumer &#125; = Context;//HoC사용function useSample(WrappedComponent) &#123; return function UseSample(props) &#123; return ( &lt;Consumer&gt; &#123; (&#123;state, actions&#125;) =&gt; ( &lt;WrappedComponent value=&#123;state.value&#125; setValue=&#123;actions.setValue&#125; /&gt; ) &#125; &lt;/Consumer&gt; ) &#125;&#125; 위의 코드를 필요한 하위 컴포넌트에서 가져다 쓰면 된다!!!1234567891011121314import React from 'react';import &#123;useSample&#125; from \"../contexts/sample\";const Receives = (&#123;value&#125;) =&gt; &#123; return ( &lt;div&gt; 현재 설정된 값: &#123;value&#125; &lt;/div&gt; );&#125;;export default useSample(Receives); redux에 비해 훨씬 더 간단하긴 하지만 redux는 단순힌 전역 상태 관리 그이상의 가치가 있다고 한다.액션기반 앱 상태 업데이트 로직 작성부터, 미들웨어, 강력한 개발자도구까지…Suspense API 또한 요즘 대세라고 한다.기존에는 리액트는 데이터가 있을 때까지 항상 로딩상태를 가지지만 Suspense API는 데이터가 있을 때까지 렌더링 되지 않는다고 한다.","categories":[],"tags":[]},{"title":"react16 주요기능","slug":"react16","date":"2018-12-04T04:05:14.000Z","updated":"2019-01-17T01:48:52.000Z","comments":true,"path":"2018/12/04/react16/","link":"","permalink":"http://juzzing2.github.io.com/2018/12/04/react16/","excerpt":"","text":"##react 16의 주요기능에 대해서 알아보자 1.return값기존의 react는 항상 return할 때마다 span태그나 배열로 감싸야했다.12345678render() &#123;return ( &lt;span&gt; &lt;Header/&gt; &lt;Footer/&gt; &lt;/span&gt; ) &#125; react16에서는 Fragment라는 것을 지원한다.또한 &lt;&gt;로도 대체 가능하다. 123456789101112import React, &#123; Component, Fragment &#125; from 'react';class Example extends Component &#123; render() &#123; return ( &lt;Fragment&gt; &lt;Header/&gt; &lt;Footer/&gt; &lt;/Fragment&gt; ); &#125;&#125; return 할때 string으로도 가능하다.123render() &#123; return \"string\" &#125; 2.Portals기존에는 리액트의 루트 밖에서 변경할 수 없었다.그러나 createPortal은 리액트 루트 밖에서 렌더할 때 사용할 수 있다.주로 iframe이나 html을 변경하지 못하거나 리액트 플러그인을 만들 때 사용한다. index.html파일12&lt;div id=\"root\"&gt;&lt;/div&gt;&lt;div id=\"portal\"&gt;&lt;/div&gt; id가 root인 애는 리액트 루트이며 portal 리액트 루트 밖에서 이용할 것이다. app.js파일1234ReactDOM.render( &lt;Main/&gt;, document.getElementById(\"root\")); Main파일1234567891011import React, &#123; Component, Fragment &#125; from 'react';import &#123; createPortal &#125; from 'react-dom';const Message = () =&gt; return \"mess\"class Main extends Component &#123; render() &#123; return ( createPortal(&lt;Message/&gt;, document.getElementById('portal')) ) &#125;&#125; 이렇게 하면 실제로 portal이라는 아이디 값에 Message라는 컴포넌트가 매핑된다. 3.Error Boundaries부모에서 child의 에러를 잡을 수 있다.이를 통해 에러를 구분하고 대처할 수 있다.componentDidCatch를 사용해서 에러를 잡을 수 있다. 1234567891011121314151617181920212223242526272829303132333435class ErrorMaker extends Component &#123; state = &#123; friends: ['ju', 'young'] &#125; componentDidMount = () =&gt; &#123; setTimeout(() =&gt; &#123; this.setState(&#123; friends: null, &#125;) &#125;, 2000) &#125; render() &#123; const &#123; friends &#125; = this.state; return friends.map(friend =&gt; `$&#123;friend&#125;`) &#125;&#125;const ErrorfallBack = () =&gt; \"Sorry\";class ExamplePortal extends Component &#123; state = &#123; hasError: false&#125;; componentDidCatch = (error, info) =&gt; &#123; this.setState(&#123; hasError: true, &#125;); console.log(`catched $&#123;error&#125; info: $&#123;JSON.stringify(info)&#125;`) &#125; render() &#123; return &#123;hasError ? &lt;ErrorfallBack/&gt; : &lt;ErrorMaker/&gt;&#125; &#125;&#125; ExamplePortal 이라는 부모 컴포넌트에서 처음엔 ErrorMaker를 보여주다가 2초가 지난 후에에러가 발생하면 ErrorfallBack 컴포넌틀르 보여준다.에러에 대한 처리를 이런식으로 하면 코드가 난잡해지며 보기 좋지 않다.그래서 나온게 HOC이다…??? –&gt;hoc정확하게 다시 알아보기!!(강의 돌려보기) 4. HOC(higher-order component)HOC는 컴포넌트를 보호한다. 12345678910111213141516171819202122232425262728293031323334const BoundaryHOC = ProtectedComponent =&gt; class Boundary extends Component &#123; state = &#123; hasError: false, &#125;; componentDidCatch = () =&gt; &#123; this.setState(&#123; hasError: true, &#125;) &#125; render () &#123; const &#123; hasError &#125; = this.state; if (hasError) &#123; return &lt;ErrorfallBack/&gt; &#125; else &#123; return &lt;ProtectedComponent/&gt; &#125; &#125; &#125; const PErrorMaker = BoundaryHOC(ErrorMaker) //컴포넌트 보호 class ExamplePortal extends Component &#123; render() &#123; return ( &lt;Fragment&gt; &lt;PErrorMaker/&gt; &lt;/Fragment&gt; ); &#125; &#125; export default BoundaryHOC(ExamplePortal); //클래스도 보호 가능 5. createRef, forwardRef기존에 ref는 자식요소에 접근할 때 이용하곤 했다.React 16.3부터는 createRef 를 사용한다. 12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react';import Test from './Test';class App extends Component &#123; constructor() &#123; super(); this.app = React.createRef(); &#125; componentDidMount() &#123; if (this.app) &#123; this.app.current.handleRef(); &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;Test ref=&#123;this.app&#125;/&gt; &lt;/div&gt; ); &#125;&#125;export default App; 123456789101112131415161718192021222324import React, &#123; Component &#125; from 'react';class Test extends Component &#123; constructor() &#123; super(); this.div = React.createRef(); &#125; handleRef = () =&gt; &#123; if (this.div) &#123; console.log(\"hi\") &#125; &#125; render() &#123; return ( &lt;div ref=&#123;this.div&#125;&gt; test &lt;/div&gt; ); &#125;&#125;export default Test; 부모요소가 app이고 test가 자식요소이다. app.js에서 didmount에서 자식요소의 함수에 접근을 하면 콘솔창에‘hi’가 찍히는 것을 볼 수 있다.그런데 만약 HOC로 test컴포넌트로 보호되어 있으면 어떻게 될까?이때는 forwardRef를 사용해야 한다. createRef는 HOC로 만들어진 컴포넌트의 속성에 ref가 있으면 리턴되는컴포넌트의 ref를 가져오기 못한다. forwardRef는 이러한 문제를 해결하기 위해서 HOC내부에서 사용하면 리턴되는컴포넌트에 전달할 수 있다. Test.js파일에서 withHOC라는 HOC로 컴포넌트가 보호되어있다는 가정하(export default withHOC(Test))에 실행해보면 된다.마찬가지로 ‘hi’가 나오는 것을 볼 수 있다. 12345import React from 'react'; const withHOC = Component =&gt; React.forwardRef((props, ref) =&gt; &#123; return &lt;Component &#123;...props&#125; ref=&#123;ref&#125; /&gt; &#125;); export default withHOC;","categories":[],"tags":[]},{"title":"webpack.cofig파일 경로 꼬임 현상","slug":"problem","date":"2018-11-28T08:52:58.000Z","updated":"2018-11-28T09:04:54.000Z","comments":true,"path":"2018/11/28/problem/","link":"","permalink":"http://juzzing2.github.io.com/2018/11/28/problem/","excerpt":"","text":"이거 땨문에 오후 내내 잡아먹었다. 자꾸 node_modules내에 있는 라이브러리가 현재 A라는 프로젝트의 abc 폴더의 경로를 보고 있었다.분명 최근에 A라는 프로젝트에서 세팅이나 이런것들이 수정된 것들이 없고 다른 쪽에서 땡겨서 쓸 때도 문제가 없었는데 말이다. 기존 구조는 A 프로젝트 - B 프로젝트 - C 프로젝트 이렇게 되어있었다.그런데 5일전 C라는 프로젝트에서 D 프로젝트를 가져다 쓰고 있었다. ( A 프로젝트 - B 프로젝트 - C 프로젝트 - D 프로젝트) 그리고 A라를 프로젝트의 webpack.config파일에 경로가 문제였다.1234567const path = require('path');resolve &#123; alias: &#123; 'abc': path.resolve(__dirname, 'abc'); &#125;&#125; 12345678const path = require('path');resolve &#123; alias: &#123; 'abc/lib': path.resolve(__dirname, 'node_modules/abc/lib'); 'abc': path.resolve(__dirname, 'abc'); &#125;&#125; 빌드를 돌면서 D라는 프로젝트에서 해당 경로를 abc로 잡는것!!이것이 문제였다. 결국 경로를 저렇게 수정했다!여기서도 abc1먼저 써야한다. abc2를 먼저 뜨면 덮어쓰더라…이렇게 고쳐서 해결했숩니다!!","categories":[],"tags":[]},{"title":"클로저(closer)란?","slug":"closer","date":"2018-11-23T04:32:21.000Z","updated":"2019-01-17T02:38:48.000Z","comments":true,"path":"2018/11/23/closer/","link":"","permalink":"http://juzzing2.github.io.com/2018/11/23/closer/","excerpt":"","text":"클로저란 과연 무엇인가?closer 폐쇄, 닫는다의 의미이다. 자바스크립트를 다루면서 책에는 나왔지만 실제로 아직 사용을 해본 적은 없다. 클로저는 함수 내부에 함수를 작성하는 것이다.클로저를 사용하는 이유는 다음과 같다. 1. 사이드 이펙트(side effect) 제어우선 side effect는 함수에서 값을 반환할 때를 제외하고 무언가를 행할 때를 가르킨다. ( ajax요청이나 timeout생성, console.log선언하는 것도…)보통 ajax, timeout과 같이 코드 흐름을 방해하는 것들이 신경쓰일 때 사용한다.12345678910var arr = []for(var i = 0; i &lt; 5; i++)&#123; //i의 값은 외부함수의 변수가 아님 arr[i] = function() &#123; return i; //결국 i에 5가 담기게 되는 이유 ==&gt; 배열을 돌게 되면 마지막으로 i =5가 되는데 return하고 있는 i의 값은 외부함수의 지역변수가 아님 &#125;&#125;for(var index in arr) &#123; console.log(arr[index]()); // 5가 다섯번찍히게 됨&#125; 위의 예제는 var가 함수 스코프를 따르기 때문에 5가 나오긴한다. let인 경우 0.1.2.3.4가 찍힌다.하지만 이 예제의 요점은 아니다. 1234567891011var arr = []for(var i = 0; i &lt; 5; i++)&#123; arr[i] = function(id)&#123; //외부함수 return function() &#123; // 내부함수 return id; &#125; &#125;(i); //외부 함수를 즉석에서 실행함&#125;for(var index in arr) &#123; console.log(arr[index]());&#125; 이 예제에서 보면 외부함수가 실행되면 외부함수의 스코프는 끝이 나기 때문에 외부함수의 인자인 id 값은 메모리에서 정리가 되어야한다.그러나 리턴이 되면서 내부함수를 실행되면서 id값인 함수의 인자와 지역변수값이 내부함수의 클로저 객체로 남아 외부함수의 인자와 변수에접근이 가능하다. 그러나 클로저를 남발하면 위험하다. 가비지컬렉션 대상이 되어여할 객체들이 메모리상에 남아있어 오버플로우가 발생할 수 있다. 2. private 변수 생성private한 변수로 접근가능하기 때문에 안전하다. 1234567891011121314151617function Hello(name) &#123; this._name = name;&#125;Hello.prototype.say = function() &#123; //prototype을 통해 객체를 다룸 console.log('Hello, ' + this._name);&#125;var hello1 = new Hello('a');var hello2 = new Hello('b');var hello3 = new Hello('c');hello1.say(); // 'Hello, a'hello2.say(); // 'Hello, b'hello3.say(); // 'Hello, c'hello1._name = 'anonymous'; //외부에서 접근 가능함hello1.say(); // 'Hello, anonymous' 위의 코드는 바로 변수에 접근해서 속성값들을 바꿀 수 있어 안전하지 않다.123456789101112131415161718function hello(name) &#123; var _name = name; return function() &#123; console.log('Hello, ' + _name); &#125;;&#125;var hello1 = hello('a');var hello2 = hello('b');var hello3 = hello('c');hello1(); // 'Hello, a'hello2(); // 'Hello, b'hello3(); // 'Hello, c'hello1 = null; // 메모리가 소모됨, 그러므로 사용이 끝나면 참조를 제거한다!hello2 = null;hello3 = null; 클로저를 사용한 예제는 private한 변수 이므로 아무리 속성값을 위와 같이 바꾸려고 해도 바뀌지 않는다.또한 사용이 끝나면 참조를 제거한다.","categories":[],"tags":[]},{"title":"iterator/generator와 async/await비교","slug":"iterator","date":"2018-11-23T04:03:24.000Z","updated":"2018-11-23T04:22:46.000Z","comments":true,"path":"2018/11/23/iterator/","link":"","permalink":"http://juzzing2.github.io.com/2018/11/23/iterator/","excerpt":"","text":"ES8부터 도입된 async/await는 iterator/generator로 부터 파생되었다.async/await의 사용하기 전에 iterator/generator부터 알아보자! iterator내부적으로 반복처리[Symbol.iterator] 반복되는 규칙을 내부적으로 처리하는 것을 만드는 부분 123456789101112131415161718//피보나치 수열 예제let fibonacci = &#123; maxStep: 20, [Symbol.iterator]() &#123; let pre = 0, cur = 1, step = 0, maxStep = this.maxStep; return &#123; next() &#123; [pre, cur] = [cur, pre + cur]; return &#123;done: step ++ &gt;= maxStep, value: cur&#125; //상태값과 value를 리턴해줌 &#125; &#125; &#125;&#125;for (let n of fibonacci) &#123; console.log(n) // 1,2,3,5,8,13,21,34 ....&#125; generatorgenerator는 iterator의 특징이자 단점인 무한 반복을 해결해준다.next해서 접근 가능 하며 기존의 {done, value}를 자동으로 리턴해준다.사용법은 function앞에 (반복기)을 붙이고 yield는 value를 정해준다.yield가 있는 시점에서 함수의 실행을멈추며 yield도 가능하다(문자열, 배열, 다른 반복기 값 가능) 12345678910111213function * factorialGenerator() &#123; let cur = 1; let count = 1; while(true) &#123; [count, cur] = [count + 1, cur * count] yield cur; &#125;&#125;const factorial = factorialGenerator();factorial.next().value // 1factorial.next().value // 2 123456789101112131415let myObj = &#123;&#125;;myObj[Symbol.iterator] = function* () &#123; yield \"1\"; //단일 값이 전달 yield* [2,3]; //yield* 로 값을 반환하면 --&gt; 해당 값이 다시 하나의 iterator로 취급되어 내부루프 처리하듯 순서대로 처리함 //배열 yield* \"45\"; //문자열 yield* innerGenerator(); //다른 반복기 값 yield \"9\";&#125;function* innerGenerator() &#123; yield 6; yield* new Set([\"7\", \"8\"]);&#125;console.log([...myObj]) // [\"1\", 2, 3, \"4\", \"5\", 6, \"7\", \"8\", \"9\"] async/await비동기를 동기처럼 보이게 한다. try, catch문을 사용해한다.기존의 * =&gt; async, yield =&gt; await로 바뀐다. 아래 코드는 async/await로 작성하는게 generator로 코드를 짜는것 보다 훨씬 가독성도 높고 코드가 간단하다.123456789101112131415161718192021function getUser() &#123; return new Promise((resolve, reject) =&gt; &#123; resolve('test'); &#125;)&#125;function* generator() &#123; const users = yield getUser(); console.log(\"user\", users) return users;&#125;const iterator = generator();const iteration = iterator.next();//generator함수 실행iteration.value.then( resolve =&gt; &#123; const nextIteration = iterator.next(resolve); nextIteration; &#125;) 12345678910111213function getUser() &#123; return new Promise((resolve, reject) =&gt; &#123; resolve('test'); &#125;)&#125;async function generator2() &#123; const users = await getUser(); console.log(users) return users;&#125;generator2();","categories":[],"tags":[]},{"title":"hexo 포스팅시 404뜨는 경우","slug":"cause","date":"2018-11-23T02:51:19.000Z","updated":"2018-11-23T02:52:46.000Z","comments":true,"path":"2018/11/23/cause/","link":"","permalink":"http://juzzing2.github.io.com/2018/11/23/cause/","excerpt":"","text":"hexo new post [파일명] 파일명은 한글로 작성했다..너무나도 당연하게 안되는건데 한시간동안 헤맷다..파일명은 영어로 작성하되 md파일에서 title만 내가 원하는 타이틀로 바꾸면 된다…","categories":[],"tags":[]},{"title":"promise와 async/await비교","slug":"promise-async","date":"2018-11-23T02:23:12.000Z","updated":"2018-11-23T04:31:22.000Z","comments":true,"path":"2018/11/23/promise-async/","link":"","permalink":"http://juzzing2.github.io.com/2018/11/23/promise-async/","excerpt":"","text":"promise- ES6 문법- resolve 결과가 then, reject가 catch문으로 가게 됨 async/await- ES8 문법- 코드의 간결성- 동기식으로 처리- await뒤에는 항상 프로미스를 반환해야한다. 차이점 정리 1. 에러처리 promise문에서 getJSON을 통해서 데이터를 받아오는 부분과 JSON.parse하는 부분에서 catch문을 사용해서 에러를 잡아야한다. 반면에 async/await 구문에서는 try, catch에서 모든 에러를 다 한번에 잡을 수 있다. 코드가 훨씬 깔끔해질 수 있다. 그러나 실무에서 에러가 발생할때 정확하게 어느 구문에서 발생했는지 알 수 없다. 123456789101112makerequest = () =&gt; &#123; try &#123; this.getJSON('a') .then(result =&gt;&#123; const data = JSON.parse(result); &#125;).catch((err) =&gt; &#123; console.log(1, err) &#125;) &#125; catch(err) &#123; console.log(2, err) &#125;&#125; 12345678makerequest = async() =&gt; &#123; try &#123; JSON.parse(await this.getJSON('a')) &#125; catch (err) &#123; console.log(\"Err\", err) &#125;&#125; 2. 중간값 처리 예를 들어서 사용자의 정보를 받아온 다음 그 정보를 바탕으로 새로운 api를 호출해야하는 경우가 있다. 이 경우 async/await를 사용하면 좀 더 편하게 코드를 짤 수 있다. 사실 이부분이 async/await를 사용하는 가장 큰 이유라고 생각한다. 12345678910makeRequest = () =&gt; &#123; return this.getJSON() .then(data =&gt; &#123; return this.makeAnotherRequest(data) .then(moreData =&gt; &#123; console.log(moreData) return moreData &#125;); &#125;)&#125; 12345makeRequest = async() =&gt; &#123; const data = await this.getJSON() const moreData = await this.makeAnotherRequest(data) console.log(moreData)&#125; 3. 디버깅 promise는 then블록 내에 디버깅을 찍으면 동기적으로 이동하기 때문에 다음 then으로 이동하지 않는다. 반면 async/await는 바로 다음 await로 이동을 하기 때문에 디버깅하는데 편리하다. async/await에서 동시에 비동기적으로 값을 가져와야할 때?이때는 Promise.all()을 사용한다.123456789101112131415161718const job = (x) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"x\", x) resolve(x); &#125;, x * 100); &#125;) &#125;timeStamp = async() =&gt; &#123; try &#123; for (const result of await Promise.all([job(3), job(6), job(9)])) &#123; console.log(result) //총 걸리는 시간은?? 15초이다! &#125; &#125; catch(err) &#123; console.log(err) &#125;&#125; 그러나 ES9에 도입된 for await가 이를 대체해준다.for await는 for of문에서 처리가능하며 반복적인 비동기 작업을 쉽게 처리해준다. 1234567891011timeStamp = async() =&gt; &#123; const promises = [3, 6, 9].map((timer) =&gt; ( new Promise((res, req) =&gt; &#123; // 총 걸리는 시간은 15초! setTimeout(() =&gt; res(timer), timer * 1000); &#125;) )) for await (const result of promises) &#123; console.log(result); &#125;&#125; 결론 promise를 대체해서 어떤 경우에서든지 async/await를 사용하는 것을 좋지 않다. 새로운 문법들이 계속 등장하는데 꼭 좋은 것만은 아니라고 한다. 적재적소로 필요할 때 사용하는게 제일 좋다. 본인한테 맞고 잘 사용할 수 있는게 좋다. 새로운 것들이 등장하는 것은 단지 이용을 편리하게 해주는것이므로…","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-11-02T04:39:39.000Z","updated":"2018-11-02T04:39:39.000Z","comments":true,"path":"2018/11/02/hello-world/","link":"","permalink":"http://juzzing2.github.io.com/2018/11/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}