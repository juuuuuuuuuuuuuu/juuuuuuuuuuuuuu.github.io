{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://juzzing2.github.io.com"},"pages":[],"posts":[{"title":"클로저(closer)란?","slug":"closer","date":"2018-11-23T04:32:21.000Z","updated":"2018-11-23T05:12:02.000Z","comments":true,"path":"2018/11/23/closer/","link":"","permalink":"http://juzzing2.github.io.com/2018/11/23/closer/","excerpt":"","text":"클로저란 과연 무엇인가?자바스크립트를 다루면서 책에는 나왔지만 실제로 아직 사용을 해본 적은 없다. 클로저는 함수 내부에 함수를 작성하는 것이다.클로저를 사용하는 이유는 다음과 같다. 1. 사이드 이펙트(side effect) 제어우선 side effect는 함수에서 값을 반환할 때를 제외하고 무언가를 행할 때를 가르킨다. ( ajax요청이나 timeout생성, console.log선언하는 것도…)보통 ajax, timeout과 같이 코드 흐름을 방해하는 것들이 신경쓰일 때 사용한다. 12345678910var arr = []for(var i = 0; i &lt; 5; i++)&#123; //i의 값은 외부함수의 변수가 아님 arr[i] = function() &#123; return i; //결국 i에 5가 담기게 되는 이유 ==&gt; 배열을 돌게 되면 마지막으로 i =5가 되는데 return하고 있는 i의 값은 외부함수의 지역변수가 아님 &#125;&#125;for(var index in arr) &#123; console.log(arr[index]()); // 5가 다섯번찍히게 됨&#125; 위의 예제는 var가 함수 스코프를 따르기 때문에 5가 나오긴한다. let인 경우 0.1.2.3.4가 찍힌다.하지만 이 예제의 요점은 아니다. 1234567891011var arr = []for(var i = 0; i &lt; 5; i++)&#123; arr[i] = function(id)&#123; //외부함수 return function() &#123; // 내부함수 return id; &#125; &#125;(i); //외부 함수를 즉석에서 실행함&#125;for(var index in arr) &#123; console.log(arr[index]());&#125; 2. private 변수 생성private한 변수로 접근가능하기 때문에 안전하다. 1234567891011121314151617function Hello(name) &#123; this._name = name;&#125;Hello.prototype.say = function() &#123; //prototype을 통해 객체를 다룸 console.log('Hello, ' + this._name);&#125;var hello1 = new Hello('a');var hello2 = new Hello('b');var hello3 = new Hello('c');hello1.say(); // 'Hello, a'hello2.say(); // 'Hello, b'hello3.say(); // 'Hello, c'hello1._name = 'anonymous'; //외부에서 접근 가능함hello1.say(); // 'Hello, anonymous' 위의 코드는 바로 변수에 접근해서 속성값들을 바꿀 수 있어 안전하지 않다.123456789101112131415161718function hello(name) &#123; var _name = name; return function() &#123; console.log('Hello, ' + _name); &#125;;&#125;var hello1 = hello('a');var hello2 = hello('b');var hello3 = hello('c');hello1(); // 'Hello, a'hello2(); // 'Hello, b'hello3(); // 'Hello, c'hello1 = null; // 메모리가 소모됨, 그러므로 사용이 끝나면 참조를 제거한다!hello2 = null;hello3 = null; 클로저를 사용한 예제는 private한 변수 이므로 아무리 속성값을 위와 같이 바꾸려고 해도 바뀌지 않는다.또한 사용이 끝나면 참조를 제거한다.","categories":[],"tags":[]},{"title":"iterator/generator와 async/await비교","slug":"iterator","date":"2018-11-23T04:03:24.000Z","updated":"2018-11-23T04:22:46.000Z","comments":true,"path":"2018/11/23/iterator/","link":"","permalink":"http://juzzing2.github.io.com/2018/11/23/iterator/","excerpt":"","text":"ES8부터 도입된 async/await는 iterator/generator로 부터 파생되었다.async/await의 사용하기 전에 iterator/generator부터 알아보자! iterator내부적으로 반복처리[Symbol.iterator] 반복되는 규칙을 내부적으로 처리하는 것을 만드는 부분 123456789101112131415161718//피보나치 수열 예제let fibonacci = &#123; maxStep: 20, [Symbol.iterator]() &#123; let pre = 0, cur = 1, step = 0, maxStep = this.maxStep; return &#123; next() &#123; [pre, cur] = [cur, pre + cur]; return &#123;done: step ++ &gt;= maxStep, value: cur&#125; //상태값과 value를 리턴해줌 &#125; &#125; &#125;&#125;for (let n of fibonacci) &#123; console.log(n) // 1,2,3,5,8,13,21,34 ....&#125; generatorgenerator는 iterator의 특징이자 단점인 무한 반복을 해결해준다.next해서 접근 가능 하며 기존의 {done, value}를 자동으로 리턴해준다.사용법은 function앞에 (반복기)을 붙이고 yield는 value를 정해준다.yield가 있는 시점에서 함수의 실행을멈추며 yield도 가능하다(문자열, 배열, 다른 반복기 값 가능) 12345678910111213function * factorialGenerator() &#123; let cur = 1; let count = 1; while(true) &#123; [count, cur] = [count + 1, cur * count] yield cur; &#125;&#125;const factorial = factorialGenerator();factorial.next().value // 1factorial.next().value // 2 123456789101112131415let myObj = &#123;&#125;;myObj[Symbol.iterator] = function* () &#123; yield \"1\"; //단일 값이 전달 yield* [2,3]; //yield* 로 값을 반환하면 --&gt; 해당 값이 다시 하나의 iterator로 취급되어 내부루프 처리하듯 순서대로 처리함 //배열 yield* \"45\"; //문자열 yield* innerGenerator(); //다른 반복기 값 yield \"9\";&#125;function* innerGenerator() &#123; yield 6; yield* new Set([\"7\", \"8\"]);&#125;console.log([...myObj]) // [\"1\", 2, 3, \"4\", \"5\", 6, \"7\", \"8\", \"9\"] async/await비동기를 동기처럼 보이게 한다. try, catch문을 사용해한다.기존의 * =&gt; async, yield =&gt; await로 바뀐다. 아래 코드는 async/await로 작성하는게 generator로 코드를 짜는것 보다 훨씬 가독성도 높고 코드가 간단하다.123456789101112131415161718192021function getUser() &#123; return new Promise((resolve, reject) =&gt; &#123; resolve('test'); &#125;)&#125;function* generator() &#123; const users = yield getUser(); console.log(\"user\", users) return users;&#125;const iterator = generator();const iteration = iterator.next();//generator함수 실행iteration.value.then( resolve =&gt; &#123; const nextIteration = iterator.next(resolve); nextIteration; &#125;) 12345678910111213function getUser() &#123; return new Promise((resolve, reject) =&gt; &#123; resolve('test'); &#125;)&#125;async function generator2() &#123; const users = await getUser(); console.log(users) return users;&#125;generator2();","categories":[],"tags":[]},{"title":"hexo 포스팅시 404뜨는 경우","slug":"cause","date":"2018-11-23T02:51:19.000Z","updated":"2018-11-23T02:52:46.000Z","comments":true,"path":"2018/11/23/cause/","link":"","permalink":"http://juzzing2.github.io.com/2018/11/23/cause/","excerpt":"","text":"hexo new post [파일명] 파일명은 한글로 작성했다..너무나도 당연하게 안되는건데 한시간동안 헤맷다..파일명은 영어로 작성하되 md파일에서 title만 내가 원하는 타이틀로 바꾸면 된다…","categories":[],"tags":[]},{"title":"promise와 async/await비교","slug":"promise-async","date":"2018-11-23T02:23:12.000Z","updated":"2018-11-23T04:31:22.000Z","comments":true,"path":"2018/11/23/promise-async/","link":"","permalink":"http://juzzing2.github.io.com/2018/11/23/promise-async/","excerpt":"","text":"promise- ES6 문법- resolve 결과가 then, reject가 catch문으로 가게 됨 async/await- ES8 문법- 코드의 간결성- 동기식으로 처리- await뒤에는 항상 프로미스를 반환해야한다. 차이점 정리 1. 에러처리 promise문에서 getJSON을 통해서 데이터를 받아오는 부분과 JSON.parse하는 부분에서 catch문을 사용해서 에러를 잡아야한다. 반면에 async/await 구문에서는 try, catch에서 모든 에러를 다 한번에 잡을 수 있다. 코드가 훨씬 깔끔해질 수 있다. 그러나 실무에서 에러가 발생할때 정확하게 어느 구문에서 발생했는지 알 수 없다. 123456789101112makerequest = () =&gt; &#123; try &#123; this.getJSON('a') .then(result =&gt;&#123; const data = JSON.parse(result); &#125;).catch((err) =&gt; &#123; console.log(1, err) &#125;) &#125; catch(err) &#123; console.log(2, err) &#125;&#125; 12345678makerequest = async() =&gt; &#123; try &#123; JSON.parse(await this.getJSON('a')) &#125; catch (err) &#123; console.log(\"Err\", err) &#125;&#125; 2. 중간값 처리 예를 들어서 사용자의 정보를 받아온 다음 그 정보를 바탕으로 새로운 api를 호출해야하는 경우가 있다. 이 경우 async/await를 사용하면 좀 더 편하게 코드를 짤 수 있다. 사실 이부분이 async/await를 사용하는 가장 큰 이유라고 생각한다. 12345678910makeRequest = () =&gt; &#123; return this.getJSON() .then(data =&gt; &#123; return this.makeAnotherRequest(data) .then(moreData =&gt; &#123; console.log(moreData) return moreData &#125;); &#125;)&#125; 12345makeRequest = async() =&gt; &#123; const data = await this.getJSON() const moreData = await this.makeAnotherRequest(data) console.log(moreData)&#125; 3. 디버깅 promise는 then블록 내에 디버깅을 찍으면 동기적으로 이동하기 때문에 다음 then으로 이동하지 않는다. 반면 async/await는 바로 다음 await로 이동을 하기 때문에 디버깅하는데 편리하다. async/await에서 동시에 비동기적으로 값을 가져와야할 때?이때는 Promise.all()을 사용한다.123456789101112131415161718const job = (x) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"x\", x) resolve(x); &#125;, x * 100); &#125;) &#125;timeStamp = async() =&gt; &#123; try &#123; for (const result of await Promise.all([job(3), job(6), job(9)])) &#123; console.log(result) //총 걸리는 시간은?? 15초이다! &#125; &#125; catch(err) &#123; console.log(err) &#125;&#125; 그러나 ES9에 도입된 for await가 이를 대체해준다.for await는 for of문에서 처리가능하며 반복적인 비동기 작업을 쉽게 처리해준다. 1234567891011timeStamp = async() =&gt; &#123; const promises = [3, 6, 9].map((timer) =&gt; ( new Promise((res, req) =&gt; &#123; // 총 걸리는 시간은 15초! setTimeout(() =&gt; res(timer), timer * 1000); &#125;) )) for await (const result of promises) &#123; console.log(result); &#125;&#125; 결론 promise를 대체해서 어떤 경우에서든지 async/await를 사용하는 것을 좋지 않다. 새로운 문법들이 계속 등장하는데 꼭 좋은 것만은 아니라고 한다. 적재적소로 필요할 때 사용하는게 제일 좋다. 본인한테 맞고 잘 사용할 수 있는게 좋다. 새로운 것들이 등장하는 것은 단지 이용을 편리하게 해주는것이므로…","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-11-02T04:39:39.000Z","updated":"2018-11-02T04:39:39.000Z","comments":true,"path":"2018/11/02/hello-world/","link":"","permalink":"http://juzzing2.github.io.com/2018/11/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}